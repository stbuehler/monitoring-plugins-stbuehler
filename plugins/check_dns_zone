#!/usr/bin/env python3

# Upstream: https://github.com/stbuehler/monitoring-plugins-stbuehler
# Copyright: Stefan BÃ¼hler
# License: MIT

from __future__ import annotations

import abc
import argparse
import dataclasses
import dns
import dns.asyncquery
import dns.dnssec
import dns.exception
import dns.message
import dns.name
import dns.rcode
import dns.rdata
import dns.rdataclass
import dns.rdataset
import dns.rdatatype
import dns.rdtypes.ANY.CNAME
import dns.rdtypes.ANY.DNSKEY
import dns.rdtypes.ANY.DS
import dns.rdtypes.ANY.NS
import dns.rdtypes.ANY.SOA
import dns.rdtypes.IN.A
import dns.rdtypes.IN.AAAA
import dns.resolver
import dns.rrset
import functools
import ipaddress
import sys
import trio
import typing


IPAddress = ipaddress.IPv4Address | ipaddress.IPv6Address
DomainName = str | dns.name.Name


class IcingaResult:
    def __init__(self, debug: bool = False) -> None:
        self._debug = debug
        self._cmp_code = -1.0
        self._code = -1
        self._title = 'OK'
        self._log: list[str] = []

    def _set(self, code: int, cmp_code: float, title: str) -> None:
        self._cmp_code = cmp_code
        self._code = code
        self._title = title

    def _add(self, code: int, cmp_code: float, msg: str, title: str) -> None:
        assert 0 <= code <= 3
        assert 0 <= cmp_code <= 2
        if cmp_code > self._cmp_code:
            self._set(code, cmp_code, msg)
        self._log.append(msg)

    def log(self, msg: str) -> None:
        self._log.append(msg)

    def debug(self, msg: str) -> None:
        if self._debug:
            self._log.append(msg)

    def info(self, msg: str) -> None:
        self._add(0, 0.0, msg, f'OK: {msg}')

    def warn(self, msg: str) -> None:
        msg = f'WARNING: {msg}'
        self._add(1, 1.0, msg, msg)

    def error(self, msg: str) -> None:
        msg = f'ERROR: {msg}'
        self._add(2, 2.0, msg, msg)

    def unknown(self, msg: str) -> None:
        msg = f'UNKNOWN: {msg}'
        self._add(3, 0.5, msg, msg)

    def finish(self) -> typing.NoReturn:
        print(f'{self._title}||')
        for line in self._log:
            print(line)
        if self._code == -1:
            self._code = 0
        sys.exit(self._code)


@dataclasses.dataclass(slots=True, frozen=True, order=True)
class DnsName:
    _name: dns.name.Name

    def __init__(self, name: str | dns.name.Name, /) -> None:
        if isinstance(name, dns.name.Name):
            object.__setattr__(self, "_name", name)
        else:
            object.__setattr__(self, "_name", dns.name.from_text(name))

    def __str__(self) -> str:
        return str(self._name)

    def __repr__(self) -> str:
        return repr(self._name)

    def is_subdomain(self, other: DnsName) -> bool:
        return self._name.is_subdomain(other._name)

    def is_root(self) -> bool:
        return self._name == dns.name.root

    def parent(self) -> DnsName:
        return DnsName(self._name.parent())

    @property
    def labels(self) -> tuple[bytes, ...]:
        return self._name.labels


TDnsRDATA = typing.TypeVar("TDnsRDATA", bound=dns.rdata.Rdata)


class RRDataBase(abc.ABC, typing.Generic[TDnsRDATA]):
    __slots__ = ()
    _RRDATATYPE: typing.ClassVar[dns.rdatatype.RdataType]
    _DNS_TYPE: typing.ClassVar[type[TDnsRDATA]]

    @abc.abstractmethod
    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdata.Rdata:
        ...

    @classmethod
    @abc.abstractmethod
    def _from_dns(cls, rr: TDnsRDATA) -> typing.Self:
        ...

    @classmethod
    def _from_dns_set(cls, rrset: dns.rrset.RRset, rrsig_set: dns.rrset.RRset | None) -> RRSet[typing.Self]:
        data: list[typing.Self] = []
        for rr in rrset:
            assert isinstance(rr, cls._DNS_TYPE)
            data.append(cls._from_dns(rr))
        rrsig: RRSIG | None = None
        return RRSet._from_dns(rrset, data, rrsig_set)

    # mypy complains with `You may not have a custom "__lt__" method when "order" is True`
    @abc.abstractmethod  # type: ignore
    def __lt__(self, other: typing.Self) -> bool: ...


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataSOA(RRDataBase[dns.rdtypes.ANY.SOA.SOA]):
    _RRDATATYPE = dns.rdatatype.SOA
    _DNS_TYPE = dns.rdtypes.ANY.SOA.SOA

    mname: DnsName  # name of primary
    rname: DnsName  # hostmaster email
    serial: int
    # time durations in seconds
    refresh: int  # secondary refresh interval (checking primary SOA serial)
    retry: int  # retry of refresh, must be less than refresh
    expire: int  # time after which secondary should consider zone stale if refresh didn't work
    minimum: int  # TTL (upper bound) of negative responses (SOA TTL itself is the other upper bound)

    def __str__(self) -> str:
        return f"SOA {self.mname} {self.rname} {self.serial} {self.refresh} {self.retry} {self.expire} {self.minimum}"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.ANY.SOA.SOA) -> RRDataSOA:
        return RRDataSOA(
            mname=DnsName(rr.mname),
            rname=DnsName(rr.rname),
            serial=rr.serial,
            refresh=rr.refresh,
            retry=rr.retry,
            expire=rr.expire,
            minimum=rr.minimum,
        )

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdtypes.ANY.SOA.SOA:
        return dns.rdtypes.ANY.SOA.SOA(
            rdclass=rdclass,
            rdtype=dns.rdatatype.SOA,
            mname=self.mname._name,
            rname=self.rname._name,
            serial=self.serial,
            refresh=self.refresh,
            retry=self.retry,
            expire=self.expire,
            minimum=self.minimum,
        )

    def strip(self, *, strip_mname: bool, strip_serial: bool) -> RRDataSOA_stripped:
        """
        When comparing SOAs we might want to ignore certain fields.
        """
        return RRDataSOA_stripped(
            mname=None if strip_mname else self.mname,
            rname=self.rname,
            serial=None if strip_serial else self.serial,
            refresh=self.refresh,
            retry=self.retry,
            expire=self.expire,
            minimum=self.minimum,
        )


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataSOA_stripped:
    """
    When comparing SOAs we might want to ignore certain fields.
    """
    mname: DnsName | None
    rname: DnsName  # hostmaster email
    serial: int | None
    # time durations in seconds
    refresh: int  # secondary refresh interval (checking primary SOA serial)
    retry: int  # retry of refresh, must be less than refresh
    expire: int  # time after which secondary should consider zone stale if refresh didn't work
    minimum: int  # TTL (upper bound) of negative responses (SOA TTL itself is the other upper bound)

    def __str__(self) -> str:
        mname = "<...>" if self.mname is None else self.mname
        serial = "<...>" if self.serial is None else self.serial
        return f"SOA {mname} {self.rname} {serial} {self.refresh} {self.retry} {self.expire} {self.minimum}"

    def unstrip(self, *, default_mname: DnsName, default_serial: int) -> RRDataSOA:
        return RRDataSOA(
            mname=default_mname if self.mname is None else self.mname,
            rname=self.rname,
            serial=default_serial if self.serial is None else self.serial,
            refresh=self.refresh,
            retry=self.retry,
            expire=self.expire,
            minimum=self.minimum,
        )


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataNS(RRDataBase[dns.rdtypes.ANY.NS.NS]):
    _RRDATATYPE = dns.rdatatype.NS
    _DNS_TYPE = dns.rdtypes.ANY.NS.NS

    target: DnsName

    def __str__(self) -> str:
        return f"NS {self.target}"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.ANY.NS.NS) -> RRDataNS:
        return RRDataNS(target=DnsName(rr.target))

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdtypes.ANY.NS.NS:
        return dns.rdtypes.ANY.NS.NS(rdclass=rdclass, rdtype=dns.rdatatype.NS, target=self.target._name)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataA(RRDataBase[dns.rdtypes.IN.A.A]):
    _RRDATATYPE = dns.rdatatype.A
    _DNS_TYPE = dns.rdtypes.IN.A.A

    address: ipaddress.IPv4Address

    def __str__(self) -> str:
        return f"A {self.address}"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.IN.A.A) -> RRDataA:
        return RRDataA(address=ipaddress.IPv4Address(rr.address))

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdtypes.IN.A.A:
        return dns.rdtypes.IN.A.A(rdclass=rdclass, rdtype=dns.rdatatype.NS, address=self.address)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataAAAA(RRDataBase[dns.rdtypes.IN.AAAA.AAAA]):
    _RRDATATYPE = dns.rdatatype.AAAA
    _DNS_TYPE = dns.rdtypes.IN.AAAA.AAAA

    address: ipaddress.IPv6Address

    def __str__(self) -> str:
        return f"AAAA {self.address}"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.IN.AAAA.AAAA) -> RRDataAAAA:
        return RRDataAAAA(address=ipaddress.IPv6Address(rr.address))

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdtypes.IN.AAAA.AAAA:
        return dns.rdtypes.IN.AAAA.AAAA(rdclass=rdclass, rdtype=dns.rdatatype.NS, address=self.address)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataDS(RRDataBase[dns.rdtypes.ANY.DS.DS]):
    _RRDATATYPE = dns.rdatatype.DS
    _DNS_TYPE = dns.rdtypes.ANY.DS.DS

    key_tag: int
    algorithm: dns.dnssectypes.Algorithm
    digest_type: dns.dnssectypes.DSDigest
    digest: bytes

    _cached_ds: dns.rdtypes.ANY.DS.DS | None = dataclasses.field(default=None, repr=False, hash=False, compare=False)

    def __str__(self) -> str:
        return f"DS {self.key_tag} {self.algorithm} {self.digest_type} {self.digest.hex()}"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.ANY.DS.DS) -> RRDataDS:
        return RRDataDS(
            key_tag=rr.key_tag,
            algorithm=rr.algorithm,
            digest_type=rr.digest_type,
            digest=rr.digest,
            _cached_ds=rr,
        )

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass) -> dns.rdtypes.ANY.DS.DS:
        ds = self._cached_ds
        if ds is None:
            ds = dns.rdtypes.ANY.DS.DS(
                rdclass=rdclass,
                rdtype=dns.rdatatype.DS,
                key_tag=self.key_tag,
                algorithm=self.algorithm,
                digest_type=self.digest_type,
                digest=self.digest,
            )
            setattr(self, "_cached_ds", ds)
        return ds

    def matches_key(self, name: DnsName, key: RRDataDNSKEY) -> bool:
        if self.key_tag != key.key_tag or self.algorithm != key.algorithm:
            return False
        cmp_ds = dns.dnssec.make_ds(name._name, key._to_dns(), self.digest_type)
        return cmp_ds.digest == self.digest


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataDNSKEY(RRDataBase[dns.rdtypes.ANY.DNSKEY.DNSKEY]):
    _RRDATATYPE = dns.rdatatype.DNSKEY
    _DNS_TYPE = dns.rdtypes.ANY.DNSKEY.DNSKEY

    flags: int
    protocol: int
    algorithm: dns.dnssectypes.Algorithm
    key: bytes
    _cached_key_tag: int | None = dataclasses.field(default=None, repr=False, hash=False, compare=False)
    _cached_dns_key: dns.rdtypes.ANY.DNSKEY.DNSKEY | None = dataclasses.field(default=None, repr=False, hash=False, compare=False)

    def __str__(self) -> str:
        return f"DNSKEY {self.flags} {self.protocol} {self.algorithm} {self.key.hex()}"

    @property
    def key_tag(self) -> int:
        key_id = self._cached_key_tag
        if key_id is None:
            key_id = dns.dnssec.key_id(self._to_dns())
            super(RRDataDNSKEY, self).__setattr__("_cached_key_tag", key_id)
        return key_id

    @staticmethod
    def _from_dns(rr: dns.rdtypes.ANY.DNSKEY.DNSKEY) -> RRDataDNSKEY:
        return RRDataDNSKEY(
            flags=rr.flags,
            protocol=rr.protocol,
            algorithm=rr.algorithm,
            key=rr.key,
            _cached_dns_key=rr,
        )

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN) -> dns.rdtypes.ANY.DNSKEY.DNSKEY:
        dns_key = self._cached_dns_key
        if dns_key is None:
            dns_key = dns.rdtypes.ANY.DNSKEY.DNSKEY(
                rdclass=rdclass,
                rdtype=dns.rdatatype.DNSKEY,
                flags=self.flags,
                protocol=self.protocol,
                algorithm=self.algorithm,
                key=self.key,
            )
            super(RRDataDNSKEY, self).__setattr__("_cached_dns_key", dns_key)
        return dns_key


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True, order=True)
class RRDataRRSIG(RRDataBase[dns.rdtypes.ANY.RRSIG.RRSIG]):
    _RRDATATYPE = dns.rdatatype.RRSIG
    _DNS_TYPE = dns.rdtypes.ANY.RRSIG.RRSIG

    _wire_data: bytes
    _cached_rrsig: dns.rdtypes.ANY.RRSIG.RRSIG | None = dataclasses.field(default=None, repr=False, hash=False, compare=False)

    def __str__(self) -> str:
        return "RRSIG <...>"

    @staticmethod
    def _from_dns(rr: dns.rdtypes.ANY.RRSIG.RRSIG) -> RRDataRRSIG:
        wire_data = rr.to_wire()
        assert wire_data
        return RRDataRRSIG(
            _wire_data=wire_data,
            _cached_rrsig=rr,
        )

    def _to_dns(self, *, rdclass: dns.rdataclass.RdataClass = dns.rdataclass.IN) -> dns.rdtypes.ANY.RRSIG.RRSIG:
        rrsig = self._cached_rrsig
        if rrsig is None:
            rdata = dns.rdata.from_wire(
                rdclass=rdclass,
                rdtype=dns.rdatatype.RRSIG,
                wire=self._wire_data,
                current=0,
                rdlen=len(self._wire_data),
            )
            assert isinstance(rdata, dns.rdtypes.ANY.RRSIG.RRSIG)
            rrsig = rdata
            super(RRDataRRSIG, self).__setattr__("_cached_rrsig", rrsig)
        return rrsig


TRRData = typing.TypeVar("TRRData", bound=RRDataBase)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class RRSIG:
    name: DnsName
    _rrsig_set: dns.rdataset.ImmutableRdataset


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class RR(typing.Generic[TRRData]):
    name: DnsName
    ttl: int
    rdclass: dns.rdataclass.RdataClass
    data: TRRData

    @staticmethod
    def _from_dns(rrset: dns.rrset.RRset, data: TRRData) -> RR[TRRData]:
        return RR(name=DnsName(rrset.name), ttl=rrset.ttl, rdclass=rrset.rdclass, data=data)

    def __str__(self) -> str:
        return f"{self.name} {self.ttl} {self.rdclass} {self.data}"


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class RRSet(typing.Generic[TRRData]):
    name: DnsName
    ttl: int
    rdclass: dns.rdataclass.RdataClass
    data: tuple[TRRData, ...]
    rrsig: RRSet[RRDataRRSIG] | None = None

    @staticmethod
    def _from_dns(
        rrset: dns.rrset.RRset,
        data: typing.Sequence[TRRData],
        rrsig_set: dns.rrset.RRset | None,
    ) -> RRSet[TRRData]:
        name = DnsName(rrset.name)
        rrsig: RRSet[RRDataRRSIG] | None = None
        if rrsig_set:
            rrsig = RRDataRRSIG._from_dns_set(rrsig_set, None)
        return RRSet(
            name=name,
            ttl=rrset.ttl,
            rdclass=rrset.rdclass,
            data=tuple(sorted(data)),
            rrsig=rrsig,
        )

    def _to_dns(self) -> dns.rrset.RRset:
        return dns.rrset.from_rdata_list(
            name=self.name._name,
            ttl=self.ttl,
            rdatas=[rr._to_dns(rdclass=self.rdclass) for rr in self.data],
        )

    def rrs(self) -> list[RR[TRRData]]:
        return [RR(name=self.name, ttl=self.ttl, rdclass=self.rdclass, data=entry) for entry in self.data]

    def __iter__(self) -> typing.Iterator[TRRData]:
        return iter(self.data)

    def validate_with_keys(self, dnskey_set: RRSet[RRDataDNSKEY]) -> bool:
        assert self.rrsig
        try:
            dns.dnssec.validate(
                self._to_dns(),
                (self.rrsig.name._name, self.rrsig._to_dns()),
                { dnskey_set.name._name: dnskey_set._to_dns() },
            )
        except dns.dnssec.ValidationFailure:
            return False
        return True


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class DSDelegation:
    name: DnsName
    ds_set: frozenset[RRDataDS]

    def _filter_dnskeys(
        self,
        dnskey_set: RRSet[RRDataDNSKEY],
    ) -> dict[dns.name.Name, dns.rdataset.Rdataset | dns.node.Node]:
        result: list[dns.rdtypes.ANY.DNSKEY.DNSKEY] = []
        for key in dnskey_set:
            if 0 == key.flags & dns.rdtypes.ANY.DNSKEY.ZONE or 3 != key.protocol:
                continue
            if any(ds.matches_key(self.name, key) for ds in self.ds_set):
                result.append(key._to_dns())
        return { self.name._name: dns.rdataset.from_rdata_list(dnskey_set.ttl, result) }

    def validate_zone_keys(self, dnskey_set: RRSet[RRDataDNSKEY]) -> bool:
        assert dnskey_set.rrsig
        acceptable_dnskeys = self._filter_dnskeys(dnskey_set)
        try:
            dns.dnssec.validate(
                dnskey_set._to_dns(),
                (dnskey_set.rrsig.name._name, dnskey_set.rrsig._to_dns()),
                acceptable_dnskeys,
            )
        except dns.dnssec.ValidationFailure:
            return False
        return True


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class Origin:
    name: DnsName
    address: IPAddress

    def __str__(self) -> str:
        return f"{self.address}({self.name})"

    def _cmp_tuple(self) -> tuple[typing.Any, ...]:
        return (self.name, self.address.version, self.address)

    def __lt__(self, other: typing.Self) -> bool:
        return self._cmp_tuple() < other._cmp_tuple()

    def __le__(self, other: typing.Self) -> bool:
        return self._cmp_tuple() <= other._cmp_tuple()

    def __gt__(self, other: typing.Self) -> bool:
        return self._cmp_tuple() > other._cmp_tuple()

    def __ge__(self, other: typing.Self) -> bool:
        return self._cmp_tuple() >= other._cmp_tuple()

    @staticmethod
    def from_resolver_address(address: IPAddress) -> Origin:
        return Origin(name=DnsName("system-resolver."), address=address)


class OriginSet:
    __slots__ = (
        "_origins",
        "_origins_by_name",
        "_origins_by_address",
        "_sorted",
        "_names",
        "_addresses",
    )

    def __init__(self, *origins: Origin) -> None:
        self._origins: set[Origin] = set()
        self._origins_by_name: dict[DnsName, list[Origin]] = {}
        self._origins_by_address: dict[IPAddress, list[Origin]] = {}
        self._sorted: tuple[Origin, ...] | None = None
        self._names: tuple[DnsName, ...] | None = None
        self._addresses: tuple[IPAddress, ...] | None = None
        for origin in origins:
            self.add(origin)

    def _insert(self, origin: Origin) -> None:
        self._sorted = None
        self._names = None
        self._addresses = None
        self._origins.add(origin)
        self._origins_by_name.setdefault(origin.name, []).append(origin)
        self._origins_by_address.setdefault(origin.address, []).append(origin)

    def add(self, origin: Origin) -> None:
        if not origin in self._origins:
            self._insert(origin)

    def add_unique_address(self, origin: Origin) -> Origin | None:
        """
        Returns (first) conflicting origin or inserts given origin

        * if origin is already in the set: returns None
        * if address is already in the set: return first origin with that address
        * otherwise: insert origin
        """
        if origin in self._origins:
            return None
        ex_origins = self._origins_by_address.get(origin.address)
        if ex_origins:
            return ex_origins[0]
        self._insert(origin)
        return None

    def __str__(self) -> str:
        origins = self.origins
        if not origins:
            return "<no origins>"
        return ", ".join(str(origin) for origin in origins)

    def __sub__(self, other: OriginSet) -> OriginSet:
        assert isinstance(other, OriginSet)
        return OriginSet(*(self._origins - other._origins))

    @property
    def origins(self) -> typing.Sequence[Origin]:
        origins = self._sorted
        if origins is None:
            self._sorted = origins = tuple(sorted(self._origins))
        return origins

    @property
    def names(self) -> typing.Sequence[DnsName]:
        names = self._names
        if names is None:
            self._names = names = tuple(sorted(self._origins_by_name))
        return names

    def names_count(self) -> int:
        return len(self._origins_by_name)

    def names_set(self) -> set[DnsName]:
        return set(self._origins_by_name)

    @property
    def addresses(self) -> typing.Sequence[IPAddress]:
        addresses = self._addresses
        if addresses is None:
            self._addresses = addresses = tuple(sorted(self._origins_by_address, key=lambda a: (a.version, a)))
        return addresses

    def addresses_count(self) -> int:
        return len(self._origins_by_address)

    def addresses_set(self) -> set[IPAddress]:
        return set(self._origins_by_address)

    def __iter__(self) -> typing.Iterator[Origin]:
        return iter(self.origins)

    @typing.overload
    def __getitem__(self, address: IPAddress, /) -> typing.Sequence[Origin]: ...

    @typing.overload
    def __getitem__(self, name: DnsName, /) -> typing.Sequence[Origin]: ...

    def __getitem__(self, index):
        if isinstance(index, (ipaddress.IPv4Address, ipaddress.IPv6Address)):
            return tuple(self._origins_by_address[index])
        if isinstance(index, DnsName):
            return tuple(self._origins_by_name[index])
        raise KeyError(f"Invalid type of index {type(index)}")

    @typing.overload
    def __contains__(self, origin: Origin, /) -> bool: ...

    @typing.overload
    def __contains__(self, address: IPAddress, /) -> bool: ...

    @typing.overload
    def __contains__(self, name: DnsName, /) -> bool: ...

    def __contains__(self, elem, /) -> bool:
        if isinstance(elem, Origin):
            return elem in self._origins
        if isinstance(elem, (ipaddress.IPv4Address, ipaddress.IPv6Address)):
            return elem in self._origins_by_address
        if isinstance(elem, DnsName):
            return elem in self._origins_by_name
        raise ValueError(f"Invalid type of elem: {type(elem)}")

    def __len__(self) -> int:
        return len(self._origins)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class CheckLimits:
    critical: float
    warning: float

    def log_if_gt(self, ir: IcingaResult, value: float, msg: str) -> None:
        if value > self.critical:
            ir.error(msg)
        elif value > self.warning:
            ir.warn(msg)


@dataclasses.dataclass(slots=True, kw_only=True, frozen=True)
class ResponseOriginCheckLimits:
    # count by name
    max_failed_ns: CheckLimits = CheckLimits(critical=2, warning=1)
    max_failed_ns_pct: CheckLimits = CheckLimits(critical=0.5, warning=0.5)
    # count per family:
    max_failed_addresses: CheckLimits = CheckLimits(critical=2, warning=1)
    max_failed_addresses_pct: CheckLimits = CheckLimits(critical=0.5, warning=0.5)
    # count by name
    max_ns_with_failure: CheckLimits = CheckLimits(critical=2, warning=1)
    max_ns_with_failure_pct: CheckLimits = CheckLimits(critical=0.5, warning=0.5)


TResponse = typing.TypeVar("TResponse")


@dataclasses.dataclass(slots=True, kw_only=True)
class ResponsesByOrigins(typing.Generic[TResponse]):
    responses: dict[TResponse, OriginSet] = dataclasses.field(default_factory=dict)

    def add_response(self, origin: Origin, response: TResponse) -> None:
        self.responses.setdefault(response, OriginSet()).add(origin)

    def single_response(self) -> TResponse | None:
        """
        If responses contains exactly one response, return that.
        """
        if len(self.responses) == 1:
            return next(iter(self.responses.keys()))
        return None

    def __iter__(self) -> typing.Iterator[tuple[TResponse, OriginSet]]:
        return iter(self.responses.items())

    def __len__(self) -> int:
        return len(self.responses)


@dataclasses.dataclass(slots=True)
class TrackOriginAvailability:
    context: str
    _failed_origins: OriginSet
    _seen_origins: OriginSet

    def __init__(self, *, context: str) -> None:
        self.context = context
        self._failed_origins = OriginSet()
        self._seen_origins = OriginSet()

    def add_origin(self, origin: Origin) -> None:
        """
        Add (expected) origin; if it doesn't fail (before or after this) success is assumed.
        """
        self._seen_origins.add(origin)

    def add_failed_origin(self, origin: Origin) -> None:
        self._failed_origins.add(origin)
        self._seen_origins.add(origin)

    def num_seen_origins(self) -> int:
        return len(self._seen_origins)

    def check(self, ir: IcingaResult, policy: ResponseOriginCheckLimits) -> None:
        # successful origins: seen and never failed
        success_origins = self._seen_origins - self._failed_origins

        if not success_origins:
            ir.error(f"{self.context}: All servers failed, tried {self._failed_origins}")
            return

        # Whether too many NS failed completely
        seen_ns = self._seen_origins.names_set()
        seen_ns_success = success_origins.names_set()
        seen_ns_fail = self._failed_origins.names_set()

        count_ns_no_success = len(seen_ns_fail - seen_ns_success)
        count_ns_total = len(seen_ns)
        policy.max_failed_ns.log_if_gt(
            ir,
            count_ns_no_success,
            f"{self.context}: Too many servers didn't respond: {self._failed_origins}",
        )
        policy.max_failed_ns_pct.log_if_gt(
            ir,
            count_ns_no_success / count_ns_total,
            f"{self.context}: Too many servers didn't respond: {self._failed_origins}",
        )

        # Whether too many NS had partial failures (on at least one address)
        count_ns_with_fails = len(seen_ns_fail)
        policy.max_ns_with_failure.log_if_gt(
            ir,
            count_ns_with_fails,
            f"{self.context}: Too many servers didn't respond: {self._failed_origins}",
        )
        policy.max_ns_with_failure_pct.log_if_gt(
            ir,
            count_ns_with_fails / count_ns_total,
            f"{self.context}: Too many servers didn't respond: {self._failed_origins}",
        )

        # Whether too many addresses failed
        failed_addresses = self._failed_origins.addresses
        all_addresses = self._seen_origins.addresses
        count_failed_ipv4 = len([a for a in failed_addresses if a.version == 4])
        count_total_ipv4 = max(len([a for a in all_addresses if a.version == 4]), 1)  # don't divide by 0
        count_failed_ipv6 = len([a for a in failed_addresses if a.version == 6])
        count_total_ipv6 = max(len([a for a in all_addresses if a.version == 6]), 1)  # don't divide by 0

        policy.max_failed_addresses.log_if_gt(
            ir,
            max(count_failed_ipv4, count_failed_ipv6),
            f"{self.context}: Too many addresses of a family didn't respond: {self._failed_origins}",
        )
        policy.max_failed_addresses_pct.log_if_gt(
            ir,
            max(count_failed_ipv4 / count_total_ipv4, count_failed_ipv6 / count_total_ipv6),
            f"{self.context}: Too many addresses of a family didn't respond: {self._failed_origins}",
        )


@dataclasses.dataclass(slots=True, kw_only=True)
class DnsTransaction:
    server: Origin
    query: dns.message.QueryMessage
    response: dns.message.Message
    used_tcp: bool


class DnsMessageError(dns.exception.DNSException):
    def __init__(self, transaction: DnsTransaction) -> None:
        self.transaction = transaction

    def __str__(self) -> str:
        server = self.transaction.server
        query = self.transaction.query.question[0]
        response = self.transaction.response
        return f"Query @{server} {query} failed with {dns.rcode.to_text(response.rcode())}"


class DnsTimeoutError(dns.exception.DNSException):
    def __init__(self, query: dns.message.Message, server: Origin) -> None:
        self.query = query
        self.server = server

    def __str__(self) -> str:
        query = self.query.question[0]
        return f"Query @{self.server} {query} timed out"


class DnsConnectionClosedError(dns.exception.DNSException):
    # created from various "server didn't like us" errors (closed through various means)
    def __init__(self, query: dns.message.Message, server: Origin, error: Exception) -> None:
        self.query = query
        self.server = server
        self.error = error

    def __str__(self) -> str:
        query = self.query.question[0]
        return f"Query @{self.server} {query} failed: server closed connection too early {self.error}"


class DnsOsError(dns.exception.DNSException):
    def __init__(self, query: dns.message.Message, server: Origin, error: OSError) -> None:
        self.query = query
        self.server = server
        self.error = error

    def __str__(self) -> str:
        query = self.query.question[0]
        return f"Query @{self.server} {query} failed: {self.error}"


class DnsInvalidResponseError(dns.exception.DNSException):
    def __init__(self, transaction: DnsTransaction, error: str) -> None:
        self.transaction = transaction
        self.error = error

    def __str__(self) -> str:
        query = self.transaction.query.question[0]
        return f"Query @{self.transaction.server} {query} failed: {self.error}"


@dataclasses.dataclass(frozen=True, kw_only=True, slots=True)
class Delegation:
    nameservers_tuple: tuple[tuple[DnsName, typing.FrozenSet[IPAddress]], ...]

    @staticmethod
    def _build(nameservers: dict[DnsName, set[IPAddress]]) -> 'Delegation':
        return Delegation(
            nameservers_tuple=tuple((ns, frozenset(nameservers[ns])) for ns in sorted(nameservers.keys())),
        )

    @property
    def nameservers(self) -> dict[DnsName, typing.FrozenSet[IPAddress]]:
        return dict(self.nameservers_tuple)

    def to_lines(self) -> typing.Generator[str, None, None]:
        for ns, addrs in self.nameservers_tuple:
            if addrs:
                yield f'* NS {ns} with glue ' + ' '.join(map(str, addrs))
            else:
                yield f'* NS {ns} - no glue'


@dataclasses.dataclass(kw_only=True, slots=True)
class SoaSets:
    soa_sets: dict[RRDataSOA, OriginSet] = dataclasses.field(default_factory=dict)
    serials: set[int] = dataclasses.field(default_factory=set)
    mnames: set[DnsName] = dataclasses.field(default_factory=set)
    _min_soas: set[RRDataSOA_stripped] = dataclasses.field(default_factory=set)

    def insert(self, soa: RRDataSOA, origin: Origin) -> None:
        # remember full SOAs
        self.soa_sets.setdefault(soa, OriginSet()).add(origin)
        # remember serials and mnames
        self.serials.add(soa.serial)
        self.mnames.add(soa.mname)
        # remember minimized SOA (without mname and serial) to count "really distinct" SOAs
        self._min_soas.add(soa.strip(strip_mname=True, strip_serial=True))

    def main_soa(self) -> RRDataSOA | None:
        if self.distinct_soas != 1:
            return None
        base_soa = next(iter(self._min_soas))
        # combination of serial and mname not necessarily seen in self.soa_sets
        return base_soa.unstrip(
            default_mname=next(iter(self.mnames)),  # select random mname
            default_serial=max(self.serials),
        )

    @property
    def distinct_soas(self) -> int:
        return len(self._min_soas)


ActionResult = typing.TypeVar('ActionResult')
async def retry_action(
    action: typing.Callable[[], typing.Awaitable[ActionResult]],
    *,
    tries: int = 3,
    timeout: float = 2.0,
    continue_exceptions: tuple[type[Exception], ...] = (),
) -> ActionResult:
    exc: Exception | None = None
    result: tuple[()] | tuple[ActionResult] = ()

    if tries < 1:
        raise ValueError(f"Can't try less than one time")

    async def single(cancel_scope: trio.CancelScope) -> None:
        nonlocal exc, result
        try:
            result = (await action(),)
            cancel_scope.cancel()
        except trio.Cancelled:
            if not (result or exc):
                raise
        except Exception as e:
            if not isinstance(e, continue_exceptions):
                # there might be previous exceptions, but they were considered less important
                # (we continued running after all)
                exc = e
                cancel_scope.cancel()
            elif exc is None:
                exc = e

    async with trio.open_nursery() as nursery:
        try:
            for _ in range(tries):
                nursery.start_soon(single, nursery.cancel_scope)
                await trio.sleep(timeout)
        except trio.Cancelled:
            if not (result or exc):
                raise

    if result:
        return result[0]
    elif exc:
        raise exc
    else:
        raise RuntimeError("internal error: Missing both exception and result")


class DnsLookup:
    @staticmethod
    def _get_first_system_resolver() -> Origin:
        resolver = dns.resolver.get_default_resolver()
        nameserver = resolver.nameservers[0]
        assert isinstance(nameserver, str), f"First nameserver must be a string containing an IP, got {nameserver!r}"
        address = ipaddress.ip_address(nameserver)
        return Origin.from_resolver_address(address)

    @staticmethod
    def _extract_answer(query: dns.message.Message, response: dns.message.Message) -> dns.rrset.RRset | None:
        q_rr: dns.rrset.RRset = query.question[0]
        rr = response.get_rrset(dns.message.ANSWER, q_rr.name, q_rr.rdclass, q_rr.rdtype)
        if rr:
            return rr
        if q_rr.rdtype == dns.rdatatype.NS:
            rr = response.get_rrset(dns.message.AUTHORITY, q_rr.name, q_rr.rdclass, q_rr.rdtype)
            if rr:
                return rr
        cname_rr: dns.rrset.RRset | None = response.get_rrset(dns.message.ANSWER, q_rr.name, dns.rdataclass.ANY, dns.rdatatype.CNAME)
        if not cname_rr:
            return None
        assert len(cname_rr) == 1
        cname_entry: dns.rdtypes.ANY.CNAME.CNAME = cname_rr[0]
        return response.get_rrset(dns.message.ANSWER, cname_entry.target, q_rr.rdclass, q_rr.rdtype)

    def __init__(self, *, server: Origin | None = None, tcp_only: bool = False) -> None:
        if server is None:
            server = DnsLookup._get_first_system_resolver()
        self._tcp_only = tcp_only
        self._server = server
        self._address_str = str(server.address)

    async def _single_query(self, query: dns.message.Message) -> tuple[dns.message.Message, bool]:
        response: dns.message.Message
        if self._tcp_only:
            used_tcp = True
            response = await dns.asyncquery.tcp(query, self._address_str)
        else:
            (response, used_tcp) = await dns.asyncquery.udp_with_fallback(query, self._address_str)
        return (response, used_tcp)

    async def _untyped_query(self, query: dns.message.QueryMessage) -> tuple[dns.rrset.RRset | None, DnsTransaction]:
        try:
            with trio.fail_after(9):
                (response, used_tcp) = await retry_action(
                    lambda: self._single_query(query),
                    continue_exceptions=(EOFError, trio.BrokenResourceError, OSError),
                )
        except (EOFError, trio.BrokenResourceError) as error:
            # with TCP query: server closed connection without answering / too early
            raise DnsConnectionClosedError(query=query, server=self._server, error=error)
        except OSError as error:
            # sadly need a quite generic catch here to handle "no route to host" (and probably similar others)
            raise DnsOsError(query=query, server=self._server, error=error)
        except trio.TooSlowError:
            raise DnsTimeoutError(query=query, server=self._server)

        tx = DnsTransaction(server=self._server, query=query, response=response, used_tcp=used_tcp)
        rcode = response.rcode()
        if not rcode in (dns.rcode.NOERROR, dns.rcode.NXDOMAIN):
            raise DnsMessageError(transaction=tx)
        answer = DnsLookup._extract_answer(query, response)
        return answer, tx

    async def query(
        self,
        name: DnsName,
        rrdata: type[TRRData],
    ) -> tuple[RRSet[TRRData] | None, DnsTransaction]:
        query = dns.message.make_query(name._name, rrdata._RRDATATYPE, want_dnssec=True)
        answer, tx = await self._untyped_query(query)
        if answer is None:
            return None, tx
        rrsig_set = tx.response.get_rrset(
            dns.message.ANSWER,
            name._name,
            dns.rdataclass.IN,
            dns.rdatatype.RRSIG,
            rrdata._RRDATATYPE,
        )
        return rrdata._from_dns_set(answer, rrsig_set), tx

    async def soa(self, name: DnsName) -> RR[RRDataSOA] | None:
        soa_set, tx = await self.query(name, RRDataSOA)
        if soa_set is None:
            return None
        soa_rrs = soa_set.rrs()
        if len(soa_rrs) != 1:
            raise DnsInvalidResponseError(transaction=tx, error="Not exactly one record in answer for SOA")
        return soa_rrs[0]

    async def ns(self, name: DnsName) -> RRSet[RRDataNS] | None:
        return (await self.query(name, RRDataNS))[0]

    async def delegation(self, name: DnsName) -> Delegation | None:
        ns_set, tx = await self.query(name, RRDataNS)
        if ns_set is None:
            return None
        nameservers: dict[DnsName, set[IPAddress]] = {}
        for ns in ns_set:
            addrs: set[IPAddress] = set()
            # only accept glue records (addresses for name) if name lives in delegated zone:
            if ns.target.is_subdomain(name):
                a_set = tx.response.get_rrset(dns.message.ADDITIONAL, ns.target._name, dns.rdataclass.IN, dns.rdatatype.A)
                if a_set:
                    for a in sorted(a_set):
                        addrs.add(ipaddress.IPv4Address(a.address))
                aaaa_set = tx.response.get_rrset(dns.message.ADDITIONAL, ns.target._name, dns.rdataclass.IN, dns.rdatatype.AAAA)
                if aaaa_set:
                    for aaaa in sorted(aaaa_set):
                        addrs.add(ipaddress.IPv6Address(aaaa.address))
            nameservers[ns.target] = addrs
        return Delegation._build(nameservers)

    async def ds(self, name: DnsName) -> RRSet[RRDataDS] | None:
        return (await self.query(name, RRDataDS))[0]

    async def find_parent_zone(self, name: DnsName) -> RRSet[RRDataNS]:
        assert name._name != dns.name.root, f"Can't get parent of root: {name!r}"
        parent = name._name
        while True:
            parent = parent.parent()
            ns = await self.ns(DnsName(parent))
            if ns:
                return ns

    async def ipv4_address(self, name: DnsName) -> list[ipaddress.IPv4Address]:
        a_set = (await self.query(name, RRDataA))[0]
        if a_set is None:
            return []
        return [ipaddress.IPv4Address(a.address) for a in a_set]

    async def ipv6_address(self, name: DnsName) -> list[ipaddress.IPv6Address]:
        aaaa_set = (await self.query(name, RRDataAAAA))[0]
        if aaaa_set is None:
            return []
        return [ipaddress.IPv6Address(aaaa.address) for aaaa in aaaa_set]

    async def addresses(self, name: DnsName) -> list[IPAddress]:
        a: list[ipaddress.IPv4Address] | None = None
        aaaa: list[ipaddress.IPv6Address] | None = None
        # avoid trio.MultiError: forward first exception we get
        exc: Exception | None = None

        async def get_v4() -> None:
            nonlocal a, exc
            try:
                a = await self.ipv4_address(name)
            except Exception as e:
                if exc is None:
                    exc = e
        async def get_v6() -> None:
            nonlocal aaaa, exc
            try:
                aaaa = await self.ipv6_address(name)
            except Exception as e:
                if exc is None:
                    exc = e

        async with trio.open_nursery() as nursery:
            nursery.start_soon(get_v4)
            nursery.start_soon(get_v6)
        if not exc is None:
            raise exc
        assert not a is None, f"get_v4 failed: {a!r}"
        assert not aaaa is None, f"get_v6 failed: {aaaa!r}"
        return [*a, *aaaa]

    async def dnskey(self, name: DnsName) -> RRSet[RRDataDNSKEY] | None:
        return (await self.query(name, RRDataDNSKEY))[0]


class DnsLookupServersCache:
    def __init__(self, *, tcp_only: bool=False):
        self._servers: dict[tuple[Origin, bool], DnsLookup] = {}
        self._tcp_only = tcp_only

    def get(self, origin: Origin, *, tcp_only: bool | tuple[()] = ()) -> DnsLookup:
        if isinstance(tcp_only, tuple):
            tcp_only = self._tcp_only
        l = self._servers.get((origin, tcp_only), None)
        if not l:
            l = DnsLookup(server=origin, tcp_only=tcp_only)
            self._servers[(origin, tcp_only)] = l
        return l


class CheckNameContext:
    def __init__(self, ir: IcingaResult, opts: Options) -> None:
        self.ir = ir
        self.opts = opts
        self.name = DnsName(opts.zone)
        resolver: Origin | None = None
        if opts.resolver:
            resolver = Origin.from_resolver_address(ipaddress.ip_address(opts.resolver))
        self.resolver = DnsLookup(server=resolver)
        self.lookup_servers = DnsLookupServersCache(tcp_only=opts.auth_tcp)
        self.host = DnsName(opts.host) if opts.host else None

        #### Values we fill during lookup ####

        # Origins (names + IP) for authoritative nameservers for the parent zone.
        # If multiple names resolve to the same address, only a single (random) name is selected.
        # Filled in `retrieve_parent_addresses`
        self.parents = OriginSet()

        # Delegations and DS sets in dictionaries where the key represents values that
        # were found mapping to a list of origins the values were received from.
        # Filled in `retrieve_delegations`
        self.parent_delegations: ResponsesByOrigins[Delegation] = ResponsesByOrigins()
        self.parent_ds_sets: ResponsesByOrigins[DSDelegation] = ResponsesByOrigins()

        # if parent_delegations has exactly one entry, this is its key
        # Set in `check_delegations`
        self.main_delegation: Delegation | None = None

        # Similar to `parent_delegations`, but results from authoritatives
        # Filled in `retrieve_auth_responses`
        self.auth_delegations: ResponsesByOrigins[Delegation] = ResponsesByOrigins()
        self.auth_dnskeys: ResponsesByOrigins[RRSet[RRDataDNSKEY]] = ResponsesByOrigins()
        self.auth_soas = SoaSets()

        # if `auth_soas` has single entry (ignoring serial and mname)
        # set in main `check`
        self.main_soa: RRDataSOA | None = None

        # `auths` similar to `parents` - only a single (random) name select per IP
        # set in main `check`
        self.auths: OriginSet = OriginSet()

    async def retrieve_parent_addresses(self) -> None:
        try:
            parent_ns_rrset = await self.resolver.find_parent_zone(self.name)
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to find parent zone for {self.name}')
            self.ir.error(str(e))
            return
        self.ir.debug(f'NS for parent zone {parent_ns_rrset.name} of {self.name}: ' + ' '.join(str(ns.target) for ns in parent_ns_rrset))

        async def get_parent_ns_addr(parent_ns: DnsName) -> None:
            try:
                addresses = await self.resolver.addresses(parent_ns)
                self.ir.debug(f'Addresses of NS {parent_ns}: ' + ' '.join(str(addr) for addr in addresses))
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to lookup addresses for NS {parent_ns} of parent zone {parent_ns_rrset.name} of {self.name}')
                self.ir.error(str(e))
                return
            for addr in addresses:
                ex_origin = self.parents.add_unique_address(Origin(name=parent_ns, address=addr))
                if ex_origin:
                    self.ir.log(f'IP {addr} duplicate in NS set for {parent_ns_rrset.name} (known as {ex_origin.name} and {parent_ns})')
            if not parent_ns in self.parents:
                self.ir.log(f'NS {parent_ns} for parent zone has no unique IPs, removing it from further consideration')

        async with trio.open_nursery() as nursery:
            for ns in parent_ns_rrset:
                nursery.start_soon(get_parent_ns_addr, ns.target)

    async def retrieve_delegations(self) -> None:
        track_delegation = TrackOriginAvailability(context=f"Delegation (NS+DS) from parent zone")
        delegations: ResponsesByOrigins[Delegation] = ResponsesByOrigins()

        async def _get_delegation(ns_origin: Origin) -> bool:
            track_delegation.add_origin(ns_origin)
            r = self.lookup_servers.get(ns_origin)
            try:
                delegation = await r.delegation(self.name)
            except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
                # assume other "OS" error indicate some kind of unreachability
                self.ir.log(f'Failed to get delegation (NS) to {self.name} from {ns_origin}')
                return False
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to get delegation (NS) to {self.name} from {ns_origin}')
                self.ir.error(str(e))
                return False
            if delegation is None:
                self.ir.error(f'Missing delegation (NS) to {self.name} from {ns_origin}')
                return False
            self.parent_delegations.add_response(ns_origin, delegation)
            try:
                ds = await r.ds(self.name)
            except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
                # assume other "OS" error indicate some kind of unreachability
                self.ir.log(f'Failed to get (dnssec) (DS) to {self.name} from {ns_origin}')
                return False
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to get (dnssec) DS to {self.name} from {ns_origin}')
                self.ir.error(str(e))
                return False
            ds_deleg: DSDelegation | None = None
            if not ds is None:
                ds_deleg = DSDelegation(name=self.name, ds_set=frozenset(ds))
                self.parent_ds_sets.add_response(ns_origin, ds_deleg)
            return True

        async def get_delegation(ns_origin: Origin) -> None:
            if await _get_delegation(ns_origin):
                track_delegation.add_origin(ns_origin)
            else:
                track_delegation.add_failed_origin(ns_origin)

        async with trio.open_nursery() as nursery:
            for ns_origin in self.parents:
                nursery.start_soon(get_delegation, ns_origin)

        track_delegation.check(self.ir, ResponseOriginCheckLimits())

        if not self.parent_delegations:
            # there should have been other errors before, but make sure to log this explicitly
            self.ir.error(f"No delegations from parent zone")


    async def check_delegations(self) -> None:
        if len(self.parent_delegations) == 0:
            self.ir.error(f'No Delegations to {self.name} anywhere')
            return

        logged_delegation: set[Delegation] = set()

        for delegation, origins in self.parent_delegations:
            missing_glue: set[DnsName] = set()
            for ns, addrs in delegation.nameservers_tuple:
                if not addrs:
                    if ns.is_subdomain(self.name):
                        missing_glue.add(ns)
            if missing_glue:
                logged_delegation.add(delegation)
                self.ir.log(f'Delegation from {origins}:')
                for line in delegation.to_lines():
                    self.ir.log(line)
                self.ir.error(f"Delegation missing glue for {' '.join(map(str, missing_glue))}")

        self.main_delegation = self.parent_delegations.single_response()
        if not self.main_delegation:
            self.ir.warn(f'Different delegations to {self.name}')

        if not self.main_delegation or self.ir._debug:
            for delegation, origins in self.parent_delegations:
                if delegation in logged_delegation:
                    # don't log twice
                    continue
                self.ir.log(f'Delegation from {origins}:')
                for line in delegation.to_lines():
                    self.ir.log(line)

        if not self.parent_ds_sets:
            self.ir.log(f'No DS records - insecure delegation')
        elif len(self.parent_ds_sets) > 1:
            self.ir.warn(f'Different DS record sets to {self.name}')
        if len(self.parent_ds_sets) > 1 or self.ir._debug:
            for dsdeleg, origins in self.parent_ds_sets:
                self.ir.log(f'DS set from {origins}:')
                for ds in dsdeleg.ds_set:
                    self.ir.log(f'* {ds}')

    async def build_merged_delegation(self) -> dict[DnsName, set[IPAddress]]:
        """
        Merge all delegations from parent auths to a single set of names mapping to IP addresses.
        Delegations might have different glue; merged all IP addresses returned for a name.
        (Delegations only contain glue addresses if the name is actually in the zone.)
        Additionally lookup all names we didn't find addresses in the delegations for (i.e. no glue).
        """
        merged_delegation: dict[DnsName, set[IPAddress]] = {}
        for delegation, _origins in self.parent_delegations:
            for ns, frozen_addrs in delegation.nameservers_tuple:
                merged_delegation.setdefault(ns, set()).update(frozen_addrs)

        async def get_unglued_ns_addr(ns: DnsName) -> None:
            if ns.is_subdomain(self.name):
                # missing glue - logged above.
                return
            try:
                addrs = await self.resolver.addresses(ns)
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to lookup (glue) addresses for NS {ns} for {self.name}')
                self.ir.error(str(e))
                return
            if not addrs:
                self.ir.error(f'NS {ns} has no addresses')
                return
            merged_delegation[ns] = set(addrs)

        async with trio.open_nursery() as nursery:
            for ns, addrs in list(merged_delegation.items()):
                if not addrs:
                    nursery.start_soon(get_unglued_ns_addr, ns)

        if self.ir._debug:
            self.ir.debug('Using merged delegation:')
            for ns, addrs in merged_delegation.items():
                self.ir.log(f'* NS {ns}: ' + ' '.join(map(str, addrs)))

        return merged_delegation

    def transpose_delegation_auths(
        self,
        auths: dict[DnsName, set[IPAddress]],
    ) -> OriginSet:
        result = OriginSet()
        for ns_name, addrs in auths.items():
            for addr in addrs:
                ex_origin = result.add_unique_address(Origin(name=ns_name, address=addr))
                if ex_origin:
                    self.ir.log(f'IP {addr} duplicate in NS set for {self.name} (known as {ex_origin.name} and {ns_name})')
        return result

    async def retrieve_auth_dnskeys(self, ns_origin: Origin) -> bool:
        l = self.lookup_servers.get(ns_origin)
        try:
            dnskey_set = await l.dnskey(self.name)
        except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
            self.ir.log(f'Failed to get DNSKEY for {self.name} from {ns_origin}')
            self.ir.log(str(sys.exception()))
            return False
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to get DNSKEY for {self.name} from {ns_origin}')
            self.ir.error(str(e))
            return False
        if not dnskey_set:
            self.ir.error(f'Missing DNSKEY for {self.name} from {ns_origin} - but delegation is secured by DS')
            return False
        if not dnskey_set.rrsig:
            self.ir.error(f'DNSKEY for {self.name} not signed from {ns_origin}')
            return False
        self.auth_dnskeys.add_response(ns_origin, dnskey_set)
        return True

    def validate_dnskeys(self) -> None:
        if not self.parent_ds_sets:
            return

        single_dnskey_set = self.auth_dnskeys.single_response()

        for dnskey_set, origins in self.auth_dnskeys:
            if not single_dnskey_set or self.ir._debug:
                self.ir.log(f"{self.name} DNSKEYs from {origins}:")
                for dnskey in dnskey_set:
                    self.ir.log(f"* {dnskey}")

            for dsdeleg, parents in self.parent_ds_sets:
                if dsdeleg.validate_zone_keys(dnskey_set):
                    self.ir.debug(f"{self.name} DNSKEYs good: from {origins} for DS from {parents}")
                else:
                    self.ir.error(f'Invalid signatures on {self.name} DNSKEY from {origins} for DS from {parents}')

    async def retrieve_auth_delegation(self, ns_origin: Origin) -> bool:
        l = self.lookup_servers.get(ns_origin)
        try:
            delegation = await l.delegation(self.name)
        except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
            self.ir.log(f'Failed to get delegation (NS) to {self.name} from authoritative {ns_origin}')
            self.ir.log(str(sys.exception()))
            return False
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to get delegation (NS) to {self.name} from authoritative {ns_origin}')
            self.ir.error(str(e))
            return False
        if delegation:
            self.auth_delegations.add_response(ns_origin, delegation)
            return True
        else:
            self.ir.error(f'Got no delegation (NS) to {self.name} from authoritative {ns_origin}')
            return False

    async def get_soa_into(self, soa_set: SoaSets, ns_origin: Origin) -> bool:
        l = self.lookup_servers.get(ns_origin)
        try:
            soa = await l.soa(self.name)
        except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
            self.ir.log(f'Failed to get SOA for {self.name} from {ns_origin}')
            self.ir.log(str(sys.exception()))
            return False
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to get SOA for {self.name} from {ns_origin}')
            self.ir.error(str(e))
            return False

        if soa:
            soa_set.insert(soa.data, ns_origin)
        else:
            self.ir.error(f'Got no SOA for {self.name} from {ns_origin}')
            return False

        other_l: DnsLookup | None = None
        other_msg = ""
        if self.opts.auth_tcp:
            if self.opts.host_udp and self.host == ns_origin.name:
                other_l = self.lookup_servers.get(ns_origin, tcp_only=False)
                other_msg = "via UDP (after successful TCP)"
        else:
            other_l = self.lookup_servers.get(ns_origin, tcp_only=True)
            other_msg = "via TCP (after successful UDP)"

        if other_l:
            try:
                other_soa = await other_l.soa(self.name)
            except (DnsTimeoutError, DnsConnectionClosedError, DnsOsError):
                self.ir.log(f'Failed to get SOA {other_msg} for {self.name} from {ns_origin}')
                self.ir.log(str(sys.exception()))
                return False
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to get SOA {other_msg} for {self.name} from {ns_origin}')
                self.ir.error(str(e))
                return False
            if other_soa != soa:
                self.ir.error(f"Got different SOA {other_msg}")
                self.ir.error(f"{other_soa} != {soa}")
                return False
            self.ir.debug(f"Successful SOA {other_msg} from {ns_origin}")

        return True

    async def retrieve_auth_response(self, soa_set: SoaSets, ns_origin: Origin) -> bool:
        success = True
        if not await self.get_soa_into(soa_set, ns_origin):
            success = False
        if not await self.retrieve_auth_delegation(ns_origin):
            success = False
        if self.parent_ds_sets:
            if not await self.retrieve_auth_dnskeys(ns_origin):
                success = False
        return success

    async def retrieve_auth_responses(self) -> None:
        track_auth_responses = TrackOriginAvailability(context="Auths")

        async def handle(ns_origin: Origin) -> None:
            if await self.retrieve_auth_response(self.auth_soas, ns_origin):
                track_auth_responses.add_origin(ns_origin)
            else:
                track_auth_responses.add_failed_origin(ns_origin)
                if ns_origin.name == self.host:
                    self.ir.error(f'Required authoritative nameserver {self.host} failed to respond (see log)')

        async with trio.open_nursery() as nursery:
            for ns_origin in self.auths:
                nursery.start_soon(handle, ns_origin)

        track_auth_responses.check(self.ir, ResponseOriginCheckLimits())
        self.validate_dnskeys()

    async def check_hidden_primary(self, hm: DnsName) -> None:
        assert self.main_soa
        hm_soas: SoaSets = SoaSets()
        track_hm = TrackOriginAvailability(context="Hidden Primary")

        async def handle(hm_origin: Origin) -> None:
            if await self.retrieve_auth_response(hm_soas, hm_origin):
                track_hm.add_origin(hm_origin)
            else:
                track_hm.add_failed_origin(hm_origin)

        try:
            hm_addrs = await self.resolver.addresses(hm)
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to lookup addresses for hidden primary {hm}')
            self.ir.error(str(e))
            return
        async with trio.open_nursery() as nursery:
            for ns_addr in hm_addrs:
                hm_origin = Origin(name=hm, address=ns_addr)
                ex_origin = self.auths.add_unique_address(hm_origin)
                if ex_origin:
                    self.ir.log(f'IP {ns_addr} of hidden primary {hm} duplicate of NS set for {self.name} (known as {ex_origin.name})')
                    continue
                nursery.start_soon(handle, hm_origin)

        if track_hm.num_seen_origins() == 0:
            self.ir.log(f"All addresses of hidden primary {hm} overlap with addresses of NS set")
            return

        track_hm.check(self.ir, ResponseOriginCheckLimits(
            max_failed_addresses=CheckLimits(critical=2, warning=0),
            max_failed_addresses_pct=CheckLimits(critical=1.0, warning=1.0),
        ))

        for soa, sources in hm_soas.soa_sets.items():
            # no need to print name for sources - there is only a single hidden primary
            sources_str = ' '.join(map(str, sources))
            if self.main_soa != soa:
                if self.main_soa == dataclasses.replace(soa, serial=self.main_soa.serial):
                    self.ir.warn(f"Hidden primary SOA from {sources_str} serial mismatch for {self.name}")
                    self.ir.log(f"Main authoritative SOA: {self.main_soa}")
                    self.ir.log(f"Hidden primary SOA from {sources_str}: {soa}")
                else:
                    self.ir.error(f"Hidden primary SOA from {sources_str} mismatch for {self.name}")
                    self.ir.log(f"Main authoritative SOA: {self.main_soa}")
                    self.ir.log(f"Hidden primary SOA from {sources_str}: {soa}")
            else:
                self.ir.debug(f"Hidden primary SOA from {sources_str} matches main SOA")

    _DIRECT_PRIVATE_ADDRESS_ZONES = {
        '10.in-addr.arpa',  # 10.0.0.0/8
        '168.192.in-addr.arpa',  # 192.168.0.0/16
        # fc00::/7 not included for now.
        # ULA: only fd00::/8 as entry; entries below can be specified through --private-entry ...
        '0.0.d.f.ip6.arpa',
    }

    def is_private_zone(self) -> bool:
        if self.opts.private:
            return True
        private_entries = {
            DnsName(part.strip())
            for entry in (self.opts.private_entry or [])
            for part in entry.split(',')
        }
        if self.name in private_entries:
            return True
        if self.opts.private_reverse:
            if self.name.is_root():
                return False
            # simply cases in self._DIRECT_PRIVATE_ADDRESS_ZONES, but shouldn't be too many
            for z in self._DIRECT_PRIVATE_ADDRESS_ZONES:
                if self.name == DnsName(z):
                    return True
            parent = self.name.parent()
            if parent == DnsName('172.in-addr.arpa'):
                # 172.16.0.0/12: 172.16 - 172.31
                if self.name.labels[0] in (f'{i}'.encode('ascii') for i in range(16, 32)):
                    return True
            elif parent == DnsName('100.in-addr.arpa'):
                # 100.64.0.0/10, 100.64 - 100.127
                if self.name.labels[0] in (f'{i}'.encode('ascii') for i in range(64, 128)):
                    return True
        return False

    async def get_private_zone_auths(self) -> dict[DnsName, set[IPAddress]]:
        result: dict[DnsName, set[IPAddress]] = {}

        async def get_ns_addr(ns: DnsName) -> None:
            try:
                result[ns] = set(await self.resolver.addresses(ns))
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to lookup addresses for NS {ns} of zone {self.name}')
                self.ir.error(str(e))
                return

        try:
            ns_set = await self.resolver.ns(self.name)
        except dns.exception.DNSException as e:
            self.ir.error(f'Failed to lookup NS for zone {self.name}')
            self.ir.error(str(e))
            return result
        if not ns_set:
            self.ir.error(f'Got no NS for zone {self.name} from resolver')
            return result

        async with trio.open_nursery() as nursery:
            for ns in ns_set:
                nursery.start_soon(get_ns_addr, ns.target)

        if self.ir._debug:
            self.ir.debug(f'Using delegation received from resolver for private zone {self.name}:')
            for ns_name, addrs in result.items():
                self.ir.log(f'* NS {ns_name}: ' + ' '.join(map(str, addrs)))

        return result

    async def check(self) -> None:
        private_zone = self.is_private_zone()
        if not private_zone:
            await self.retrieve_parent_addresses()
            await self.retrieve_delegations()
            await self.check_delegations()

            auths_by_name = await self.build_merged_delegation()
        else:
            self.ir.log("Not checking delegation, was marked as private zone entry")
            auths_by_name = await self.get_private_zone_auths()

        if len(auths_by_name) == 0:
            # there should have been an error message about this already
            self.ir.error("Can't continue without authoritative nameservers to query")
            return

        delegated_auths: set[DnsName] = set(auths_by_name)

        if self.host and not self.host in delegated_auths:
            # add explicit host to NS
            try:
                auths_by_name[self.host] = set(await self.resolver.addresses(self.host))
            except dns.exception.DNSException as e:
                self.ir.error(f'Failed to lookup addresses for explicit NS-host {self.host} of zone {self.name}')
                self.ir.error(str(e))
                return

        self.auths = self.transpose_delegation_auths(auths_by_name)

        await self.retrieve_auth_responses()

        if self.auth_soas.distinct_soas == 0:
            self.ir.error(f'Found no SOA for {self.name}')
            return

        log_soas = False
        if self.auth_soas.distinct_soas == 1:
            self.main_soa = self.auth_soas.main_soa()
            if len(self.auth_soas.serials) > 1:
                self.ir.warn(f'Found multiple SOA serials for {self.name}')
                log_soas = True
            if len(self.auth_soas.mnames) > 1:
                self.ir.log(f'Found multiple SOA mnames for {self.name}')
                log_soas = True
            if not log_soas:
                self.ir.log(f'Found single SOA: {self.name} SOA {self.main_soa}')

        if log_soas or self.ir._debug:
            if not log_soas:
                self.ir.debug('SOAs from authoritatives:')
            for soa, sources in self.auth_soas.soa_sets.items():
                self.ir.log(f'From {sources}:')
                self.ir.log(f'  {self.name} SOA {soa}')

        if self.main_soa:
            if not self.main_soa.mname in delegated_auths:
                self.ir.log(f'Found hidden primary {self.main_soa.mname}')
                if not self.opts.skip_hidden_primary:
                    if self.main_soa.mname == self.host:
                        # this would only show "duplicate IP in NS"
                        self.ir.log(f'Checked hidden primary as explicit host already')
                    else:
                        await self.check_hidden_primary(self.main_soa.mname)
                else:
                    self.ir.log(f'Not checking hidden primary as requested')
            else:
                self.ir.debug(f'SOA mname {self.main_soa.mname} is a public auth, no hidden primary detected')

        # This includes the delegation received from the hidden primary, so
        # `check_hidden_primary` must come before this.
        logged_expected_delegation = False
        if self.main_delegation:
            for delegation, sources in self.auth_delegations:
                if self.main_delegation != delegation:
                    if not logged_expected_delegation:
                        logged_expected_delegation = True
                        self.ir.log('Delegation:')
                        for line in self.main_delegation.to_lines():
                            self.ir.log(line)
                    self.ir.warn(f'Different delegation data from authoritatives {sources}:')
                    for line in delegation.to_lines():
                        self.ir.log(line)
                else:
                    self.ir.debug(f'Delegation matched data from authoritive {sources}')
        elif private_zone:
            # Can't compare with delegation from parent(s), so check between auths
            if len(self.auth_delegations) > 1:
                self.ir.error("Multiple delegations from authoritatives")
            if len(self.auth_delegations) > 1 or self.ir._debug:
                for delegation, sources in self.auth_delegations:
                    self.ir.log(f'Delegation data from authoritatives {sources}:')
                    for line in delegation.to_lines():
                        self.ir.log(line)

        expect_auths = [
            DnsName(auth.strip().lower())
            for opt in (self.opts.expect_auth or [])
            for auth in opt.split(',')
        ]
        for auth in expect_auths:
            if not auth in delegated_auths:
                self.ir.error(f'Missing expected auth {auth} in NS set for {self.name}')
            else:
                self.ir.debug(f'Found expected auth {auth} in NS set for {self.name}')

        if self.main_delegation:
            self.ir.log('+ Checked delegation with authoritative')
        if self.parent_ds_sets:
            self.ir.log('+ Checked DNSSEC delegation with authoritative')
        if self.main_soa:
            if self.opts.auth_tcp:
                if self.opts.host and self.opts.host_udp:
                    self.ir.log(f'+ Checked SOA records via TCP (plus UDP for {self.host})')
                else:
                    self.ir.log('+ Checked SOA records via TCP')
            else:
                self.ir.log('+ Checked SOA records via UDP + TCP')


@dataclasses.dataclass(slots=True, kw_only=True)
class Options:
    zone: str
    skip_hidden_primary: bool
    auth_tcp: bool
    debug: bool
    expect_auth: list[str] | None
    private: bool
    private_reverse: bool
    private_entry: list[str] | None
    resolver: str
    host: str
    host_udp: bool

    @staticmethod
    def parse() -> Options:
        p = argparse.ArgumentParser(description="Check DNS zone (delegation, SOA, DNSSEC) on all authoritatives and hidden primary")
        p.add_argument('zone', help='Name of DNS zone to check')
        p.add_argument('--skip-hidden-primary', '--skip-hidden-master', action='store_true', help="Don't verify hidden primary data (might be blocked by a firewall)")
        p.add_argument('--auth-tcp', action='store_true', help="Use TCP for DNS queries to authoritative servers")
        p.add_argument('--debug', action='store_true', help="Show debug output")
        p.add_argument('--expect-auth', action='append', help="Make sure listed servers are part of the NS set of the zone")
        p.add_argument('--private', action='store_true', help="Don't check the delegation (i.e. only SOA)")
        p.add_argument('--private-reverse', action='store_true', help="Don't check the delegation (i.e. only SOA), if the zone is an entry to the reverse zone for private IP addresses")
        p.add_argument('--private-entry', action='append', help="Mark given zone name(s) as entry to private zones where delegation isn't checked")
        p.add_argument('--resolver', action='store', help="Use given address as DNS resolver")
        p.add_argument('--host', action='store', help="Make sure zone is hosted on given host")
        p.add_argument('--host-udp', action='store_true', help="Check SOA via UDP too (when --auth-tcp is used) for nameserver given via --host")
        opts = p.parse_args()
        return Options(**opts.__dict__)


def main():
    try:
        opts = Options.parse()
        ir = IcingaResult(debug=opts.debug)
        trio.run(CheckNameContext(ir, opts).check)
    except Exception as e:
        import traceback
        ir.unknown("Unknown exception")
        # although traceback returns "lines", they include \n - undo that
        for line in ''.join(traceback.format_exception(e)).splitlines():
            ir.log(line)
    ir.finish()


if __name__ == '__main__':
    main()
